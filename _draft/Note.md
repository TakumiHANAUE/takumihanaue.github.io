# 2 次元極座標での運動方程式

# 3 次元極座標での運動方程式

# [Julia language](https://julialang.org/)

## C/C++との違い

[Noteworthy differences from C/C++](https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-C/C)

- Julia の配列の`[]`に記述するインデックスは一次元だけでなく`A[i,j]`のように二次元も書ける。この表記は C/C++のようにポインタやアドレスのシンタックスシュガーではない。
- Julia の配列インデックスは 1 から始まる。
- Julia の配列を他の変数に代入してもコピーされない。例えば、`A = B`したあと、`B`を変更すると`A`も併せて変更される。  
  `+=`のような演算はその場で行われるのではなく、`A = A + B`と同じになる。つまり左辺が右辺の結果に結び付けられる。
- C/C++の配列は行優先であるのに対して、Julia の配列は列優先である。これは配列をループする際に性能最適化を図るため。
  また、ループの順序は C/C++と比べて Julia では逆順にするのが良い。
- Julia の値は代入するときや関数に渡されるときににコピーされない。関数が配列の値を変更したときは呼び出し元でも変更されている。
- Julia ではスペースが重要だ。C/C++とは違って、スペースの追加・削除には注意を払わないといけない。
- Julia では、小数点を持たない literal number (例えば`42`) は singned integer (`Int`) になる。
  機器のワードサイズに充てるには大きすぎる場合は自動的により大きい型(`Int64`, `Int128`, `BigInt`など)に変更される。
  `L`, `LL`, `U`, `UL`, `ULL` といった literal number の suffix はない。
  10 進のリテラルは常に signed になり、16 進のリテラルは unsigned になる（ただし、`BigInt`として使われる場合を除く）。
  16 進のリテラルはその桁数に応じて型が変わる。
  例えば、`0x0`や`0x00`は`UInt8`になり、`0x000`や`0x0000`は`UInt16`になる。同様にして 5 ～ 8 桁は`UInt32`、9 ～ 16 桁は`UInt64`、17 ～ 32 桁は`UInt128`、それ以上の桁数では`BigInt`となる。
  そのため、16 進数でマスクをするときに考慮しないといけない。
  例えば、`~0xf == 0xf0` は `~0x000f == 0xfff0` とはまったく異なる。
  `Float64`と`Float32`はリテラルではそれぞれ`1.0`, `1.0f0` と表される。
  浮動小数点数リテラルは正確に表現できない場合は丸められる（`BigFloat` に変更されない）。これは C/C++での振る舞いと似ている。
  8 進(prefix は `0o`)と 2 進(prefix は `0b`)は unsigned となる（`BigInt`に変更され得る）。
- Julia では`/`演算子は浮動小数点数を返す。`div`や`÷`演算子は整数を返す。
- Julia では配列のインデックスに浮動小数点数を使うとエラーになる。
  C 言語での`a[i / 2]`と同じ表現は、Julia では`a[i ÷ 2 + 1]`となる（`i`は整数）。
- 文字列リテラルは`"`や`"""`で区切られる。`"""`で区切るときは`"`をエスケープしなくてよい。
  文字列リテラルには変数や数式の値を挿入することができ、`$変数`や`$(数式)`として文字列に記述する。
- `//`は 1 行コメントではなく有理数を指す（1 行コメントには`#`を使う）。
- `#=`で複数行コメントが始まり`=#`で終わる。
- Julia では関数の返り値は、最後の数式の値か、`return`で返す。
  複数の値を返す場合は tuple を使う。例えば `(a, b) = myfunction()` や `a, b = myfunction()` とする。
  C/C++ みたいに 関数にポインタを渡して複数の返り値を受け取ることはしない。
- Julia は statement の最後にセミコロンは必要ない。
  数式の結果は自動で表示されず、コード行はセミコロンで終わる必要はない。
  `println`や`@printf`を使って出力を行う。
  REPL では`;`は出力抑制に使われるが、`[ ]` の中では意味が異なる。
  `;`は同じ行の中で数式を区切るために使われるが、多くの場合厳密に必要ではなく読みやすさのために使われる。
- Julia では `⊻`(`xor`)演算は XOR 演算（C/C++での`^`）を表す。
  演算子の優先順位は C/C++ と異なるので、括弧が必要になる。
- Julia では`^`演算子はべき乗を表す。
- Julia には右シフトの演算子が二つあり、`>>` と `>>>` である。
  `>>>` は算術シフトで、 `>>` は論理シフトとなる（C/C++では型によって`>>`の意味が変わる）。
- Julia では `->` は匿名関数を生成する。ポインタ通してメンバにアクセスできない。
- Julia では、`if`, `for`, `while` 文で括弧は必要ない（例えば、`for i in [1, 2, 3]` や `if i == 1` とする）。
- Julia は `0`や`1`を Booleans として扱わない。つまり `if (1)` とは書けない。
  `if` 文は booleans のみ受け付けるので、 `if true` や `if Bool(1)`、 `if 1==1` と書くことができる。
- Julia では`if`, `for`, `while` 文や関数のブロック終わりは `end` で表す。
  1 行で書く`if (cond) statement` の代わりに、Julia では`if cond; statement; end` や `cond && statement`、`!cond || statement` と書ける。
  後ろの 2 つの表記で値の代入を行う場合は、演算子の優先順位の都合で括弧が必要となる（`cond && (x = value)`）。
- Julia は 行を続ける表記はない。行末で数式が完結していると判断できる場合は、そこで数式が切れる。
  もし、複数行にわたって数式を続けたい場合は括弧を使う。
- Julia のマクロは parsed expression として働く。
  マクロ名は `@` で始まり、関数表記 `@mymacro(arg1, arg2, arg3)` と文表記 `@mymacro arg1 arg2 arg3` で書ける。
  これらの表現は相互に交換可能。
  文表記はブロックに注釈を付ける時に使われる（`@distributed for i in 1:n; #= body =#; end`）。
  マクロの終端が不明瞭なときは関数表記を使う方が良い。
- Julia は enum 型を持っていて、マクロで `@enum(name, value1, value2, ...)` と表現される（例えば `@enum(Fruit, banana=1, apple, pear)`）。
- 慣例として、引数を変更する関数の名前には最後に`!`を付ける。
- Julia では全てのメソッドは "virtual" となる。
